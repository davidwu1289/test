public class FieldInfo {
    private final String name;
    private final String type;
    private final int length;

    public FieldInfo(String name, String type, int length) {
        this.name = name;
        this.type = type;
        this.length = length;
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    public int getLength() {
        return length;
    }
}

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.List;

public class DataValidator {
    private final List<FieldInfo> schema;

    public DataValidator(List<FieldInfo> schema) {
        this.schema = schema;
    }

    // Function to check if a string contains any special characters
    private boolean containsSpecialCharacters(String s) {
        return !s.matches("^[a-zA-Z0-9]+$");
    }

    // Function to validate an individual record
    public void validateRecord(String record) {
        int position = 0;

        // Iterate over each field in the schema
        for (FieldInfo field : schema) {
            // Extract the field value from the record
            String fieldValue = record.substring(position, position + field.getLength());

            // Check the field length
            if (fieldValue.length() != field.getLength()) {
                throw new IllegalArgumentException("Field " + field.getName() + " in record " + record + " has incorrect length.");
            }

            // Check the field type and value
            switch (field.getType()) {
                case "Numeric":
                    // For numeric fields, check that the value is a number and is right-justified (no leading spaces).
                    if (!fieldValue.matches("\\d+") || !fieldValue.equals(fieldValue.trim())) {
                        throw new IllegalArgumentException("Field " + field.getName() + " in record " + record + " has non-numeric value or is not right-justified.");
                    }
                    break;
                case "String":
                    // For string fields, check that the value does not contain special characters and is left-justified (no trailing spaces).
                    if (containsSpecialCharacters(fieldValue) || !fieldValue.equals(fieldValue.trim())) {
                        throw new IllegalArgumentException("Field " + field.getName() + " in record " + record + " has special characters or is not left-justified.");
                    }
                    break;
                case "Date":
                    // For date fields, check that the value follows the CYYMMDD format.
                    String century = fieldValue.charAt(0) == '0' ? "19" : "20";
                    String year = century + fieldValue.substring(1, 3);
                    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd");
                    dateFormat.setLenient(false);
                    try {
                        dateFormat.parse(year + fieldValue.substring(3));
                    } catch (ParseException e) {
                        throw new IllegalArgumentException("Field " + field.getName() + " in record " + record + " has incorrect date format.");
                    }
                    break;
                case "Timestamp":
                    // For timestamp fields, check that the value follows the CCYYMMDDHHMMSSSSSSS format.
                    century = fieldValue.substring(0, 2).equals("00") ? "19" : "20";
                    year = century + fieldValue.substring(2, 4);
                    SimpleDateFormat timestampFormat = new SimpleDateFormat("yyyyMMddHHmmssSSSSSS");
                    timestampFormat.setLenient(false);
                    try {
                        timestampFormat.parse(year + fieldValue.substring(4));
                    } catch (ParseException e) {
                        throw new IllegalArgumentException("Field " + field.getName() + " in record " + record + " has incorrect timestamp format.");
                    }
                    break;
                default:
                    // Unsupported field type
                    throw new IllegalArgumentException("Field type '" + field.getType() + "' is not supported.");
            }

            // Update the position for the next field
            position += field.getLength();
        }
    }
}


import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

public class DataProcessor {
    private final List<FieldInfo> schema;
    private final DataValidator dataValidator;

    public DataProcessor(List<FieldInfo> schema) {
        this.schema = schema;
        this.dataValidator = new DataValidator(schema);
    }

    // Function to process the data file, validate records, and split into output files
    public void processDataFile(String dataFilePath, String controlFilePath, String outputDir, Integer linesPerFile, Integer sizePerFile) throws IOException {
        // Read the control file to get the expected record count
        int expectedRecordCount = readControlFile(controlFilePath);

        // Read and validate the data file
        int actualRecordCount = readAndValidateDataFile(dataFilePath);

        // Check if the number of records in the data file matches the count mentioned in the control file
        if (expectedRecordCount != actualRecordCount) {
            throw new IllegalStateException("Data file contains " + actualRecordCount + " records, but the control file specifies " + expectedRecordCount + " records.");
        }

        // Split the data into output files based on the provided options
        splitDataIntoOutputFiles(dataFilePath, outputDir, linesPerFile, sizePerFile);
    }

    // Function to read the control file and get the expected record count
    private int readControlFile(String controlFilePath) throws IOException {
        // Implement the control file reading logic here
        // ...
        return 0; // Replace this with the actual expected record count read from the control file
    }

    // Function to read and validate the data file
    private int readAndValidateDataFile(String dataFilePath) throws IOException {
        int recordCount = 0;

        try (BufferedReader br = Files.newBufferedReader(Paths.get(dataFilePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                // Validate each record
                dataValidator.validateRecord(line);
                recordCount++;
            }
        }

        return recordCount;
    }

    // Function to split the data into output files based on the provided options
    private void splitDataIntoOutputFiles(String dataFilePath, String outputDir, Integer linesPerFile, Integer sizePerFile) throws IOException {
        // Implement the data splitting logic here
        // ...
    }
}


public class Main {
    public static void main(String[] args) {
        // Define the schema
        List<FieldInfo> schema = Arrays.asList(
                new FieldInfo("WS-CIF-CUST NO", "Numeric", 15),
                new FieldInfo("WS-XCM-COID-N", "Numeric", 5),
                // ... Add the rest of the fields from your schema here ...
        );

        // Initialize the DataProcessor
        DataProcessor dataProcessor = new DataProcessor(schema);

        // Set the file paths and other parameters
        String dataFile = "path/to/data/file.dat";
        String controlFile = "path/to/control/file.txt";
        String outputDir = "path/to/output/directory";
        Integer linesPerFile = 1000000; // Set the desired number of lines per output file
        Integer sizePerFile = null; // Set the desired size per output file in bytes

        try {
            // Process the data file
            dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile);
        } catch (IOException e) {
            System.err.println("Error processing the data file: " + e.getMessage());
        }
    }
}


import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

public class DataProcessor {
    // ... (other methods and fields)

    // Function to split the data into output files based on the provided options
    private void splitDataIntoOutputFiles(String dataFilePath, String outputDir, Integer linesPerFile, Integer sizePerFile) throws IOException {
        int fileCounter = 1;
        int lineCounter = 0;
        long currentFileSize = 0;
        String currentOutputFileName = outputDir + File.separator + "output" + fileCounter + ".dat";

        try (BufferedReader br = Files.newBufferedReader(Paths.get(dataFilePath));
             BufferedWriter bw = new BufferedWriter(new FileWriter(currentOutputFileName))) {

            String line;
            while ((line = br.readLine()) != null) {
                // Write the line to the current output file
                bw.write(line);
                bw.newLine();

                // Update line and file counters
                lineCounter++;
                currentFileSize += line.length() + 1; // Add 1 for the new line character

                // Check if we need to start a new output file based on linesPerFile or sizePerFile
                if ((linesPerFile != null && lineCounter >= linesPerFile) || (sizePerFile != null && currentFileSize >= sizePerFile)) {
                    // Close the current output file and reset counters
                    bw.flush();
                    bw.close();

                    // Start writing to a new output file
                    fileCounter++;
                    lineCounter = 0;
                    currentFileSize = 0;
                    currentOutputFileName = outputDir + File.separator + "output" + fileCounter + ".dat";
                    bw = new BufferedWriter(new FileWriter(currentOutputFileName));
                }
            }
        }
    }
}


List<FieldInfo> schema = Arrays.asList(
        new FieldInfo("WS-CIF-CUST NO", "Numeric", 15),
        new FieldInfo("WS-XCM-COID-N", "Numeric", 5),
        new FieldInfo("WS-CIF-CUS-TO-COM-PURPOSE-CDE", "String", 7),
        new FieldInfo("WS-CIF-CUS-TO-COM-METHOD-ID", "String", 100),
        new FieldInfo("WS-CIF-CUS-TO-EML-NICK-NAME", "String", 25),
        new FieldInfo("WS-CIF-CUS-TO-COM-LAST MAINT", "Date", 7),
        new FieldInfo("WS-COM-FEAT-CDE-1", "String", 3),
        new FieldInfo("WS-COM-FEAT-STAT-1", "String", 2),
        new FieldInfo("WS-COM-FEAT-STAT-TS-1", "Timestamp", 20),
        new FieldInfo("WS-FEAT-STAT-RSN-1", "String", 5),
        new FieldInfo("WS-TC-ACPT-TS-1", "Timestamp", 20),
        new FieldInfo("WS-TC-VRSN-EFF-DATE-1", "Date", 7),
        new FieldInfo("WS-COM-FEAT-CDE-2", "String", 3),
        new FieldInfo("WS-COM-FEAT-STAT-2", "String", 2),
        new FieldInfo("WS-COM-FEAT-STAT-TS-2", "Timestamp", 20),
        new FieldInfo("WS-FEAT-STAT-RSN-2", "String", 5),
        new FieldInfo("WS-TC-ACPT-TS-2", "Timestamp", 20),
        new FieldInfo("US-WS-FC-VRSN-EFF-DATE-2", "Date", 7),
        new FieldInfo("WS-COM-FEAT-CDE-3", "String", 3),
        new FieldInfo("WS-COM-FEAT-STAT-3", "String", 2),
        new FieldInfo("S-COM-FEAT-STAT-TS-3", "Timestamp", 20),
        new FieldInfo("WS-FEAT-STAT-RSN-3", "String", 5),
        new FieldInfo("WS-TC-ACPT-TS-3", "Timestamp", 20),
        new FieldInfo("WS-TC-VRSN-EFF-DATE-3", "Date", 7)
);



import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class DataProcessorTest {

    @Test
    public void testValidDataFile_AllRecordsCorrect() {
        // Test case 1: Valid Data File, All Records Correct
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters
        String dataFile = "test-data/valid_data_file.dat";
        String controlFile = "test-data/valid_control_file.txt";
        String outputDir = "test-data/output";
        Integer linesPerFile = 1000000;
        Integer sizePerFile = null;

        // Execute the method and verify the outcome
        assertDoesNotThrow(() -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
        // Add more assertions here if required for specific verification
    }

    @Test
    public void testInvalidDataFile_IncorrectNumberInControlFile() {
        // Test case 2: Invalid Data File, Incorrect Number of Records in Control File
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters with an incorrect number of records in the control file
        String dataFile = "test-data/valid_data_file.dat";
        String controlFile = "test-data/invalid_control_file.txt";
        String outputDir = "test-data/output";
        Integer linesPerFile = 1000000;
        Integer sizePerFile = null;

        // Execute the method and verify the outcome
        assertThrows(IllegalStateException.class, () -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
    }

    @Test
    public void testInvalidDataFile_InvalidFieldDataType() {
        // Test case 3: Invalid Data File, Invalid Field Data Type
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters with a data file containing invalid data type in a field
        String dataFile = "test-data/invalid_data_file_datatype.dat";
        String controlFile = "test-data/valid_control_file.txt";
        String outputDir = "test-data/output";
        Integer linesPerFile = 1000000;
        Integer sizePerFile = null;

        // Execute the method and verify the outcome
        assertThrows(IllegalStateException.class, () -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
    }

    @Test
    public void testInvalidDataFile_InvalidFieldLength() {
        // Test case 4: Invalid Data File, Invalid Field Length
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters with a data file containing fields with incorrect lengths
        String dataFile = "test-data/invalid_data_file_length.dat";
        String controlFile = "test-data/valid_control_file.txt";
        String outputDir = "test-data/output";
        Integer linesPerFile = 1000000;
        Integer sizePerFile = null;

        // Execute the method and verify the outcome
        assertThrows(IllegalStateException.class, () -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
    }

    @Test
    public void testInvalidDataFile_SpecialCharacters() {
        // Test case 5: Data File with Special Characters
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters with a data file containing records with special characters
        String dataFile = "test-data/invalid_data_file_specialchars.dat";
        String controlFile = "test-data/valid_control_file.txt";
        String outputDir = "test-data/output";
        Integer linesPerFile = 1000000;
        Integer sizePerFile = null;

        // Execute the method and verify the outcome
        assertThrows(IllegalStateException.class, () -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
    }

    @Test
    public void testValidDataFile_SplitByLinesPerFile() {
        // Test case 6: Valid Data File, Splitting Based on Lines Per File
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters with splitting based on lines per file
        String dataFile = "test-data/valid_data_file.dat";
        String controlFile = "test-data/valid_control_file.txt";
        String outputDir = "test-data/output_lines";
        Integer linesPerFile = 1000000;
        Integer sizePerFile = null;

        // Execute the method and verify the outcome
        assertDoesNotThrow(() -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
        // Add more assertions here if required for specific verification
    }

    @Test
    public void testValidDataFile_SplitBySizePerFile() {
        // Test case 7: Valid Data File, Splitting Based on Size Per File
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters with splitting based on size per file
        String dataFile = "test-data/valid_data_file.dat";
        String controlFile = "test-data/valid_control_file.txt";
        String outputDir = "test-data/output_size";
        Integer linesPerFile = null;
        Integer sizePerFile = 52428800; // 50 MB (size in bytes)

        // Execute the method and verify the outcome
        assertDoesNotThrow(() -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
        // Add more assertions here if required for specific verification
    }

    @Test
    public void testValidDataFile_SplitByBothLinesAndSizePerFile() {
        // Test case 8: Valid Data File, Splitting Based on Both Lines Per File and Size Per File
        // Create DataProcessor with the schema
        DataProcessor dataProcessor = new DataProcessor(getSchema());

        // Set input parameters with splitting based on both lines per file and size per file
        String dataFile = "test-data/valid_data_file.dat";
        String controlFile = "test-data/valid_control_file.txt";
        String outputDir = "test-data/output_both";
        Integer linesPerFile = 1000000;
        Integer sizePerFile = 52428800; // 50 MB (size in bytes)

        // Execute the method and verify the outcome
        assertDoesNotThrow(() -> dataProcessor.processDataFile(dataFile, controlFile, outputDir, linesPerFile, sizePerFile));
        // Add more assertions here if required for specific verification
    }

    // Helper method to create the schema for the test cases
    private List<FieldInfo> getSchema() {
        return Arrays.asList(
                new FieldInfo("WS-CIF-CUST NO", "Numeric", 15),
                new FieldInfo("WS-XCM-COID-N", "Numeric", 5),
                // ... Add the rest of the fields from your schema here ...
        );
    }
}


